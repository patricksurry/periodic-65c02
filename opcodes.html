<!DOCTYPE html>

<head>
    <style>
        text {
            font-size: 10px;
            font-family: 'proxima-nova', sans-serif;
            fill: #333;
        }

        text,
        tspan {
            text-anchor: middle;
            alignment-baseline: middle;
        }

        rect {
            stroke: white;
            stroke-opacity: 0.5;
            fill-opacity: 0.5;
        }

        text.mnemonic {
            font-size: 14px;
            fill: #333;
        }

        text.op {
            text-anchor: start;
            alignment-baseline: before-edge;
            font-size: 12px;
        }

        text.flags :not(.affected) {
            fill-opacity: 0.3;
        }

        tspan.mode {
            font-style: italic;
        }

        .cycles {
            stroke: #333;
            stroke-width: 2;
        }

        .tick1 {
            stroke-opacity: 0.5;
        }

        .tick0 {
            stroke-opacity: 0.1;
        }

        .ext {
            stroke: #333;
        }

        .ext-65C02 {
            fill: none;
        }

        .ext-R65C02 {
            fill-opacity: 0.25;
        }

        .ext-W65C02 {
            fill-opacity: 0.5;
        }
    </style>
</head>

<body>
    <div id="container"></div>
    <script type="module">

        import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

        // Declare the chart dimensions and margins.
        const width = 80, height = 60, border = 30;
        const colors = d3.schemeSet3;
        const sixteen = [...Array(16).keys()],
            eight = sixteen.slice(0, 8);

        const data = await d3.json('opcodes.json'),
            table = sixteen.map(d => data.slice(d * 16, (d + 1) * 16));

        function fmt_mnemonic(d) {
            var s = d.mnemonic;
            if (d.arg) s += ' ' + d.arg;
            [['a8', 'zp'], ['a16', 'llhh'], ['d8', 'dd'], ['r8', 'rr']].forEach(
                ([from, to]) => {s = s.replace(from, `/${to}/`);}
            );
            return s.split(/\//);
        }

        function fmt_op(d) {
            return d.opcode.toUpperCase() + '\u2009\u25A2'.repeat(d.bytes - 1);
        }

        function fmt_cycles(d) {
            const
                slash = d.cycles.includes('/'),
                n = +d.cycles.split(/\D/).slice(slash ? -1 : 0)[0],
                branch = slash ? n + 1 : n,
                page = d.cycles.includes('+') ? branch + 1 : branch;

            return eight.map(i => i < n ? 3 : (i < branch ? 2 : (i < page ? 1 : 0)));
        }

        function bg_color(d) {
            if (!d) return 'grey';
            if (d.mnemonic.match(/^((LD|ST)[^P]|(T[AXYS][AXYS]))/)) {
                /* load, store, transfer */
                return colors[0];
            } else if (d.mnemonic.match(/^(PH|PL)/)) {
                /* stack */
                return colors[9];
            } else if (d.mnemonic.match(/^(DE|IN)/)) {
                /* inc, dec */
                return colors[2];
            } else if (d.mnemonic.match(/^(AD|SB)C/)) {
                /* arithmetic */
                return colors[4];
            } else if (d.mnemonic.match(/^(AND|EOR|ORA)/)) {
                /* boolean */
                return colors[5];
            } else if (d.mnemonic.match(/^(ASL|LSR|RO[RL])/)) {
                /* bit shift */
                return colors[11];
            } else if (d.mnemonic.match(/^(CL|SE)/)) {
                /* flag ops */
                return colors[6];
            } else if (d.mnemonic.match(/^(CMP|CP[XY])/)) {
                /* comparisons */
                return colors[10];
            } else if (d.mnemonic.match(/^B[BCENMPV]|BRA/)) {
                /* branch */
                return colors[7];
            } else if (d.mnemonic.match(/^(JMP|JSR|RTS|RTI|BRK|NOP|WAI|STP)/)) {
                /* flow control */
                return colors[3];
            } else if (d.mnemonic.match(/^(BIT|RMB|SMB|TRB|TSB)/)) {
                /* bit tests */
                return colors[1];
            } else {
                return 'blue';
            }
        }

        // Create the SVG container.
        const svg = d3.create("svg")
            .attr("width", width * 16 + 2 * border)
            .attr("height", height * 16 + 2 * border);;

        const cells = svg.append('g')
            .selectAll(".row")
            .data(table)
            .join("g")
            .attr('class', 'row')
            .attr('transform', (_, i) => 'translate(0,' + height * (i + 0.5) + ')')
            .selectAll(".cell")
            .data(d => d)
            .join("g")
            .attr('class', 'cell')
            .attr('transform', (_, i) => 'translate(' + width * (i + 0.5) + ',0)')

        cells.append('rect')
            .attr('width', width).attr('height', height)
            .attr('fill', bg_color)
            .attr('x', -width / 2).attr('y', -height / 2);

        const valid = cells.filter(d => d);
        valid.append('text')
            .attr('class', 'op')
            .attr('x', -width / 2).attr('y', -height / 2)
            .attr('dx', 5).attr('dy', 5)
            .text(fmt_op);

        valid.append('text')
            .attr('class', 'mnemonic')
            .attr('dy', 4)
            .selectAll('tspan')
            .data(fmt_mnemonic)
            .join('tspan')
            .classed('mode', (_, i) => i == 1)
            .text(d => d);

        valid.append('text')
            .attr('class', 'flags')
            .attr('y', height / 2)
            .attr('dy', -8)
            .selectAll('tspan')
            .data(d => d.flags)
            .join('tspan')
            .text((_, i) => 'NZCIDV'[i])
            .classed('affected', (d, i) => d == 'NZCIDV'[i]);

        valid.append('g')
            .attr('transform', `translate(${width / 2 - 12},${-height / 2 + 12})`)
            .attr('class', 'cycles')
            .selectAll('line')
            .data(fmt_cycles)
            .join("line")
            .attr("class", d => `tick${d}`)
            .attr("transform", (_, i) => `rotate(${i * 360 / 8})`)
            .attr("y1", d => d == 2 ? -5 : -3).attr("y2", -7);

        valid.filter(d => d.ext)
            .append("path")
            .attr("class", d => `ext ext-${d.ext}`)
            .attr("transform", `translate(${width / 2}, ${height / 2})`)
            .attr("d", "m -5,-5 l 0,-10 l -10,10 z");
        // Append the SVG element.
        container.append(svg.node());

    </script>
</body>

</html>
